//! Authentication types for Ed25519 challenge-response protocol.
//!
//! This module defines the core types used in the phone authentication system:
//! - `Challenge`: Generated by the desktop to authenticate a phone
//! - `ChallengeResponse`: Signed response from the phone
//! - `AuthError`: Error types for authentication operations

use serde::{Deserialize, Serialize};
use thiserror::Error;

/// Size of the challenge in bytes (256-bit security).
pub const CHALLENGE_SIZE: usize = 32;

/// Size of the nonce in bytes for replay prevention.
pub const NONCE_SIZE: usize = 16;

/// Challenge expiry time in seconds.
pub const CHALLENGE_EXPIRY_SECS: u64 = 30;

/// Maximum number of active challenges to prevent DoS attacks.
pub const MAX_ACTIVE_CHALLENGES: usize = 100;

/// A cryptographic challenge for phone authentication.
///
/// The challenge is generated by the desktop and sent to the phone.
/// The phone signs the challenge with its Ed25519 private key and
/// returns a `ChallengeResponse`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct Challenge {
    /// Base64-encoded 32-byte random challenge.
    pub challenge: String,
    /// Base64-encoded 16-byte nonce for replay prevention.
    pub nonce: String,
    /// Unix timestamp when the challenge was created.
    pub timestamp: u64,
    /// Identifier of the desktop that generated the challenge.
    pub desktop_id: String,
}

impl Challenge {
    /// Returns the raw challenge bytes decoded from base64.
    ///
    /// # Errors
    ///
    /// Returns `AuthError::CryptoError` if base64 decoding fails.
    pub fn challenge_bytes(&self) -> Result<Vec<u8>, AuthError> {
        use base64::Engine;
        base64::engine::general_purpose::STANDARD
            .decode(&self.challenge)
            .map_err(|e| AuthError::CryptoError(format!("Failed to decode challenge: {e}")))
    }

    /// Returns the raw nonce bytes decoded from base64.
    ///
    /// # Errors
    ///
    /// Returns `AuthError::CryptoError` if base64 decoding fails.
    pub fn nonce_bytes(&self) -> Result<Vec<u8>, AuthError> {
        use base64::Engine;
        base64::engine::general_purpose::STANDARD
            .decode(&self.nonce)
            .map_err(|e| AuthError::CryptoError(format!("Failed to decode nonce: {e}")))
    }

    /// Creates the message that should be signed by the phone.
    ///
    /// The message format is: `challenge || nonce || timestamp || desktop_id`
    /// This ensures the signature covers all challenge parameters.
    pub fn signing_message(&self) -> Vec<u8> {
        let mut message = Vec::new();
        message.extend_from_slice(self.challenge.as_bytes());
        message.extend_from_slice(self.nonce.as_bytes());
        message.extend_from_slice(&self.timestamp.to_le_bytes());
        message.extend_from_slice(self.desktop_id.as_bytes());
        message
    }
}

/// A signed response to an authentication challenge.
///
/// The phone creates this by signing the challenge with its Ed25519 private key.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct ChallengeResponse {
    /// The nonce from the original challenge (for lookup).
    pub nonce: String,
    /// Base64-encoded Ed25519 signature over the challenge message.
    pub signature: String,
    /// Identifier of the phone that created this response.
    pub phone_id: String,
}

impl ChallengeResponse {
    /// Returns the raw signature bytes decoded from base64.
    ///
    /// # Errors
    ///
    /// Returns `AuthError::CryptoError` if base64 decoding fails.
    pub fn signature_bytes(&self) -> Result<Vec<u8>, AuthError> {
        use base64::Engine;
        base64::engine::general_purpose::STANDARD
            .decode(&self.signature)
            .map_err(|e| AuthError::CryptoError(format!("Failed to decode signature: {e}")))
    }
}

/// Errors that can occur during authentication operations.
#[derive(Debug, Error)]
pub enum AuthError {
    /// A cryptographic operation failed.
    #[error("Cryptographic operation failed: {0}")]
    CryptoError(String),

    /// The challenge has expired or was not found.
    #[error("Challenge expired or not found")]
    ChallengeExpired,

    /// The signature verification failed.
    #[error("Invalid signature")]
    InvalidSignature,

    /// A nonce was reused (potential replay attack).
    #[error("Nonce reuse detected")]
    NonceReuse,

    /// Too many active challenges (DoS protection triggered).
    #[error("Too many active challenges")]
    TooManyChallenges,

    /// The public key is invalid.
    #[error("Invalid public key: {0}")]
    InvalidPublicKey(String),
}

#[cfg(test)]
mod tests {
    use super::*;
    use base64::Engine;

    #[test]
    fn test_challenge_signing_message() {
        let challenge = Challenge {
            challenge: base64::engine::general_purpose::STANDARD.encode([0u8; 32]),
            nonce: base64::engine::general_purpose::STANDARD.encode([1u8; 16]),
            timestamp: 1234567890,
            desktop_id: "test-desktop".to_string(),
        };

        let message = challenge.signing_message();
        assert!(!message.is_empty());
        // Verify message contains all components
        assert!(message.len() > 32 + 16 + 8); // base64 + timestamp bytes + desktop_id
    }

    #[test]
    fn test_challenge_bytes_valid() {
        let raw_challenge = [42u8; 32];
        let challenge = Challenge {
            challenge: base64::engine::general_purpose::STANDARD.encode(raw_challenge),
            nonce: base64::engine::general_purpose::STANDARD.encode([0u8; 16]),
            timestamp: 0,
            desktop_id: String::new(),
        };

        let bytes = challenge.challenge_bytes().unwrap();
        assert_eq!(bytes, raw_challenge);
    }

    #[test]
    fn test_challenge_bytes_invalid_base64() {
        let challenge = Challenge {
            challenge: "not-valid-base64!!!".to_string(),
            nonce: String::new(),
            timestamp: 0,
            desktop_id: String::new(),
        };

        let result = challenge.challenge_bytes();
        assert!(matches!(result, Err(AuthError::CryptoError(_))));
    }

    #[test]
    fn test_response_signature_bytes() {
        let raw_sig = [0u8; 64];
        let response = ChallengeResponse {
            nonce: String::new(),
            signature: base64::engine::general_purpose::STANDARD.encode(raw_sig),
            phone_id: String::new(),
        };

        let bytes = response.signature_bytes().unwrap();
        assert_eq!(bytes.len(), 64);
    }

    #[test]
    fn test_challenge_serialization() {
        let challenge = Challenge {
            challenge: "dGVzdA==".to_string(),
            nonce: "bm9uY2U=".to_string(),
            timestamp: 1234567890,
            desktop_id: "desktop-1".to_string(),
        };

        let json = serde_json::to_string(&challenge).unwrap();
        let parsed: Challenge = serde_json::from_str(&json).unwrap();
        assert_eq!(challenge, parsed);
    }

    #[test]
    fn test_response_serialization() {
        let response = ChallengeResponse {
            nonce: "bm9uY2U=".to_string(),
            signature: "c2lnbmF0dXJl".to_string(),
            phone_id: "phone-1".to_string(),
        };

        let json = serde_json::to_string(&response).unwrap();
        let parsed: ChallengeResponse = serde_json::from_str(&json).unwrap();
        assert_eq!(response, parsed);
    }
}
